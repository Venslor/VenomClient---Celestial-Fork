package net.pvproom.client

import com.google.gson.JsonParser
import org.apache.commons.io.FileUtils
import net.pvproom.client.event.EventManager
import net.pvproom.client.event.EventTarget
import net.pvproom.client.event.impl.AuthEvent
import net.pvproom.client.event.impl.GameStartEvent
import net.pvproom.client.event.impl.GameTerminateEvent
import net.pvproom.client.game.GameProperties
import net.pvproom.client.game.LaunchCommand
import net.pvproom.client.game.LaunchCommandJson
import net.pvproom.client.game.addon.JavaAgent
import net.pvproom.client.gui.elements.unzipNatives
import net.pvproom.client.utils.GitUtils
import net.pvproom.client.utils.OSEnum
import net.pvproom.client.utils.currentJavaExec
import org.slf4j.LoggerFactory
import java.awt.Toolkit
import java.awt.datatransfer.StringSelection
import java.io.BufferedReader
import java.io.File
import java.io.InputStreamReader
import java.nio.charset.StandardCharsets
import javax.swing.JOptionPane
import kotlin.system.exitProcess

private var log = LoggerFactory.getLogger(Wrapper::class.java)

object Wrapper {
    @EventTarget
    fun onAuth(e: AuthEvent) {
        log.info("Request for login")
        val clipboard = Toolkit.getDefaultToolkit().systemClipboard
        clipboard.setContents(StringSelection(e.authURL.toString()), null)
        val link = JOptionPane.showInputDialog(
            null,
            f.getString("gui.launcher.auth.message"),
            f.getString("gui.launcher.auth.title"),
            JOptionPane.QUESTION_MESSAGE
        )
        e.put(link)
    }
}

fun main() {
    EventManager.register(Wrapper) // handle login requests
    log.info("Powered by Venom")
    log.info(
        "Venom is running on Java: " + System.getProperty("java.version") + " JVM: " + System.getProperty(
            "java.vm.version"
        ) + "(" + System.getProperty("java.vendor") + ") Arch: " + System.getProperty("os.arch")
    )
    log.info("Venom v${GitUtils.buildVersion} build by ${GitUtils.buildUser}")
    log.info("Git remote: ${GitUtils.remote} (${GitUtils.branch})")
    val jsonPath = System.getProperty("room.json")
    val commandFile = jsonPath?.toFile() ?: launchJson
    log.info("Launching via $commandFile")
    // parse command file
    val launchCommandJson = JSON.decodeFromString<LaunchCommandJson>(commandFile.readText(StandardCharsets.UTF_8))
    // to launch command
    val command = launchCommandJson.complete()
    val code = launch(command).waitFor()
    log.info("Game terminated (code=$code)")
    exitProcess(0)
}

fun generateScripts(): String {
    val sb = StringBuilder()
    val classpath = System.getProperty("java.class.path")
    if (OSEnum.current == OSEnum.Windows) {
        sb
            .append("@echo off\n")
            .append("@rem This script was generated by Venom Launcher v${GitUtils.buildVersion}\n")
            .append("@rem Powered by Venom\n")
            .append("@rem View the real commandline in ${launchJson.name}\n")
    } else {
        sb.append("# This script was generated by Venom Launcher v${GitUtils.buildVersion}\n")
            .append("# Powered by Venom\n")
            .append("# View the real commandline in ${launchJson.name}\n")
    }
    val command = mutableListOf<String>()
    command.add(currentJavaExec.path)
    command.add("-cp")
    val splitChar = if (OSEnum.Windows.isCurrent) ";" else ":"
    command.add(classpath.split(splitChar).joinToString(splitChar) {
        // use absolute path
        File(it).absolutePath
    })
    command.add("-Droom.json=${launchJson.path}")
    command.add(Wrapper::class.java.canonicalName + "Kt")
    command.map {
        sb.append(if (it.contains(" ")) "\"${it}\"" else it).append(" ")
    }
    return sb.toString()
}

private fun LaunchCommandJson.complete(): LaunchCommand {
    val javaAgents = JavaAgent.findEnabled()
    if (config.addon.weave.state) {
        log.info("Weave is enabled!")
        javaAgents.add(JavaAgent(path = config.addon.weave.installationDir, classpath = false))
    }
    if (config.addon.lunarcn.state) {
        log.info("LunarCN is enabled!")
        log.warn("LunarCN Loader is deprecated.")
        javaAgents.add(JavaAgent(config.addon.lunarcn.installationDir))
    }
    if (config.addon.lcqt.state) {
        log.info("LunarQT is enabled!")
        javaAgents.add(JavaAgent(config.addon.lcqt.installationDir))
    }
    log.info("Found ${javaAgents.count()} javaagents")
    return LaunchCommand(
        installation = this.installation.toFile(),
        jre = this.jre.toFile(),
        wrapper = this.wrapper,
        mainClass = this.mainClass,
        natives = this.natives.map { File(it) },
        vmArgs = this.vmArgs,
        programArgs = this.programArgs,
        javaAgents = javaAgents,
        classpath = this.classpath.map { it.toFile() },
        ichorpath = this.ichorpath.map { it.toFile() },
        ipcPort = this.ipcPort,
        gameVersion = this.gameVersion,
        gameProperties = GameProperties(
            config.game.resize.width,
            config.game.resize.height,
            File(config.game.gameDir)
        )
    )
}

/**
 * Patching network disabling for LunarClient
 */
fun completeSession() {
    if (!sessionFile.exists()) {
        log.info("Completing session.json to fix the network error for LunarClient")
        var json: ByteArray?
        "/game/session.json".getInputStream().use { stream ->
            json = stream?.readAllBytes()
        }
        FileUtils.writeStringToFile(
            sessionFile, JsonParser.parseString(
                String(
                    json!!, StandardCharsets.UTF_8
                )
            ).toString(), StandardCharsets.UTF_8
        )
    }
}

fun launch(cmd: LaunchCommand): Process {
    log.info("Patching network disable...")
    completeSession()
    log.info("Unzipping natives")
    try {
        cmd.natives.forEach {
            it.unzipNatives(cmd.installation)
        }
    } catch (e: Exception) {
        log.error("Failed to unzip natives. Does the game running?")
        log.error(e.stackTraceToString())
    }
    log.info("Starting websocket server...")
    val server = cmd.startWebsocketServer()
    if (server == null) {
        log.info("The websocket server was disabled.")
    }
    log.info("Generating command...")
    // wait 1s for the websocket server start
    Thread.sleep(1000)
    val commandList = cmd.generateCommand(server?.port ?: -1)
    log.debug(commandList.joinToString(" "))
    log.info("Executing command...")
    val pb = ProcessBuilder(commandList)
        .redirectErrorStream(true)
        .directory(cmd.installation)
    if (OSEnum.Linux.isCurrent) {
        // check is Wayland+Nvidia env
        if (System.getenv("XDG_SESSION_TYPE") == "wayland" && File("/usr/bin/nvidia-smi").exists()) {
            log.info("Nvidia+Wayland detected, disabled GL_THREADED_OPTIMIZATIONS flag")
            pb.environment()["__GL_THREADED_OPTIMIZATIONS"] = "0"
        }
    }
    val process = pb.start()
    val pid = process.pid()
    Thread {
        // redirect logs
        BufferedReader(InputStreamReader(process.inputStream)).use { reader ->
            reader.lines().forEach { line -> log.info(line) }
        }
    }.start()
    Thread.sleep(3000) // wait 3s
    log.info("Game is running! (PID: $pid)")
    GameStartEvent(pid).call()
    process.onExit().thenAccept {
        GameTerminateEvent(it.exitValue()).call()
        server?.stop()
    }
    return process
}

fun launchPrevious(): Process {
    val launchCommandJson = JSON.decodeFromString<LaunchCommandJson>(launchJson.readText(StandardCharsets.UTF_8))
    return launch(launchCommandJson.complete())
}